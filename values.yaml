ctfd:
  image:
    # -- repository link to the CTFd docker image
    repository: ghcr.io/ctfd/ctfd
    # -- image pull policy. One of Always, Never, IfNotPresent
    pullPolicy: IfNotPresent
    # -- CTFd image tag (check https://github.com/CTFd/CTFd/pkgs/container/ctfd)
    # @default -- `latest`
    tag: "latest"
  # -- Image pull secrets (use this for private repos)
  imagePullSecrets: []

  # -- CTFd replica count (If autoscaling is enabled, this value is ignored)
  replicaCount: 3
  # custom scaling metrics should be considered like the Req/sec and # of sessions, etc.
  autoscaling:
    # -- Enables HPA autoscaling
    enabled: true
    # -- Autoscaling min replicas
    minReplicas: 3
    # -- Autoscaling max replicas
    maxReplicas: 20
    # -- Autoscaling target CPU utilization percentage
    targetCPUUtilizationPercentage: 80
    # -- Autoscaling target memory utilization percentage
    targetMemoryUtilizationPercentage: 80
  resources:
    limits:
      # -- CTFd pod CPU limit
      cpu: "2"
      # -- CTFd pod memory limit
      memory: 2Gi
    requests:
      # -- CTFd pod CPU request
      cpu: "1"
      # -- CTFd pod memory request
      memory: 1Gi

  # Default env variables (non exhaustive). Refer to CTFd documentation for more
  # No need to set SECRET_KEY, its generated automatically
  # @ignored
  env:
    - name: WORKERS
      value: "2"  # let HPA handle autoscaling instead of increasing workers inside the same pod
    - name: ACCESS_LOG
      value: "-"
    - name: ERROR_LOG
      value: "-"
    - name: REVERSE_PROXY
      value: "true"
    - name: LOG_FOLDER
      value: "/var/log/CTFd"
    - name: UPLOAD_PROVIDER
      value: "s3"  # The chart only supports S3

  uploadprovider:
    s3:
      # -- AWS S3 bucket name
      bucket: ""  # external bucket (you should disable SeaweedFS. See below)
      # -- AWS S3 bucket region
      endpoint_url: ""
      # -- AWS S3 bucket access key
      secret_access_key: ""
      # -- AWS S3 bucket secret key id
      access_key_id: ""

  ingress:
    # -- Enables ingress
    enabled: true
    # -- Ingress class
    className: ""
    # -- Ingress annotations
    annotations:
      # -- Max body size for uploads (Check CTFd github repository's nginx configurations)
      nginx.ingress.kubernetes.io/proxy-body-size: "2G"
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    # @ignored
    hosts:
      - host: ctfd.example.com
        paths:
          - path: /
            pathType: ImplementationSpecific
    # @ignored
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local
  updateStrategy:
    # -- CTFd update strategy rolling update max surge (extra pods during rolling update)
    maxSurge: 3
    # -- CTFd update strategy rolling update max unavailable pods count
    maxUnavailable: 25%

  pdb:
    # -- Deploy a [PodDisruptionBudget] for the application controller
    enabled: true
    # -- Number of pods that are available after eviction as number or percentage (eg.: 50%)
    # @default -- `""` (defaults to 0 if not specified)
    minAvailable: ""
    # -- Number of pods that are unavailable after eviction as number or percentage (eg.: 50%).
    ## Has higher precedence over `controller.pdb.minAvailable`
    maxUnavailable: "50%"

  # @ignored
  service:
    type: ClusterIP
    port: 8000

  # CTFd security context
  # @default -- Check `values.yaml`. Runs as CTFd user
  securityContext:
    runAsNonRoot: true
    runAsUser: 1001

  # -- CTFd readiness probe
  # @default -- Check `values.yaml`
  livenessProbe:
    httpGet:
      path: /healthcheck
      port: http
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5

  # -- CTFd readiness probe
  # @default -- Check `values.yaml`
  readinessProbe:
    httpGet:
      path: /healthcheck
      port: http
    initialDelaySeconds: 60
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5

  initContainers: []

  # -- Chart name override
  nameOverride: ""
  # -- Chart fullname override
  fullnameOverride: ""

  # -- CTFd node selector
  nodeSelector: {}

  # -- CTFd tolerations
  tolerations: []

  # -- CTFd affinity
  affinity: {}

  # -- CTFd pod annotations
  podAnnotations: {}

  # -- CTFd pod labels
  podLabels: {}

  # -- CTFd pod security context
  podSecurityContext: {}

  # -- CTFd volumes
  volumes: []

  # --  CTFd volumeMounts
  volumeMounts: []

  serviceAccount:
    # Specifies whether a service account should be created
    # -- creates a CTFd service account
    create: true
    # Automatically mount a ServiceAccount's API credentials?
    # -- CTFd service account mount API credentials
    automount: true
    # Annotations to add to the service account
    # -- CTFd service account annotations
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    # -- CTFd service account name
    name: ""

## MariaDB-Galera subchart values. Set `mariadb-galera.enabled` to `false` to use an external database (set mariadb-galera.external)
mariadb-galera:
  # -- Deploys bitnami's mariadb-galera (set to false if you want to use an external database)
  enabled: true
  # -- Number of primary nodes replicas
  replicaCount: 3
  db:
    # -- ctfd database user
    user: ctfd
    # -- ctfd database password
    password: ctfd
    # -- ctfd database name
    name: ctfd
  # -- backup user (This is required by the subchart to do helm upgrades)
  galera:
    mariabackup:
      # -- backup user (This is required by the subchart to do helm upgrades)
      password: ctfd
  rootUser:
    # -- root user
    password: ctfd
  # -- request and limits preset (check bitnami's mariadb-galera chart for details)
  resourcesPreset: large
  persistence:
    enabled: true
    # -- PVC size
    size: 2Gi
  # -- primary entrypoint extra flags
  # @default -- Check `values.yaml`. Used by official CTFd `docker-compose.yml`
  extraFlags: "--character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci --wait_timeout=28800 --log-warnings=0"
  metrics:
    enabled: false  # prometheus metrics exporter
  # -- External database connection details. Takes effect if `mariadb.enabled` is set to false
  # @default -- ignored
  external:
    port: 3306
    host: external-mariadb-host
    username: ""
    password: ""
    database: ""

## Redis-HA subchart values. Set `redis-ha.enabled` to `false` to use an external Redis cache (set redis-ha.external)
# Ref: https://github.com/DandyDeveloper/charts/blob/master/charts/redis-ha/values.yaml
redis-ha:
  # -- Enables the Redis HA subchart and disables the custom Redis single node deployment
  enabled: true
  # -- Redis-HA replicas
  replicas: 3
  ## Redis image
  image:
    # -- Redis repository
    repository: public.ecr.aws/docker/library/redis
    # -- Redis tag
    tag: 7.4.1-alpine
  ## Prometheus redis-exporter sidecar
  exporter:
    # -- Enable Prometheus redis-exporter sidecar
    enabled: false
    # -- Repository to use for the redis-exporter
    image: public.ecr.aws/bitnami/redis-exporter
    # -- Tag to use for the redis-exporter
    tag: 1.58.0
  persistentVolume:
    # -- Configures persistence on Redis nodes
    enabled: false
  ## Redis specific configuration options
  redis:
    # -- Redis convention for naming the cluster group: must match `^[\\w-\\.]+$` and can be templated
    masterGroupName: ctfd
    # -- Any valid redis config options in this section will be applied to each server (see `redis-ha` chart)
    # @default -- See [values.yaml]
    config:
      # -- Will save the DB if both the given number of seconds and the given number of write operations against the DB occurred. `""`  is disabled
      # @default -- `'""'`
      save: '""'
  ## Enables a HA Proxy for better LoadBalancing / Sentinel Master support. Automatically proxies to Redis master.
  haproxy:
    # -- Enabled HAProxy LoadBalancing/Proxy
    enabled: true
    # -- HAProxy replicas
    replicas: 3
    metrics:
      # -- HAProxy enable prometheus metric scraping
      enabled: false
    # -- Whether the haproxy pods should be forced to run on separate nodes.
    hardAntiAffinity: true
    # -- Additional affinities to add to the haproxy pods.
    additionalAffinities: {}
    # -- Assign custom [affinity] rules to the haproxy pods.
    affinity: |

    # -- [Tolerations] for use with node taints for haproxy pods.
    tolerations: []
    # -- HAProxy container-level security context
    # @default -- See [values.yaml]
    containerSecurityContext:
      readOnlyRootFilesystem: true

  # -- Configures redis-ha with AUTH
  auth: false

  # -- Whether the Redis server pods should be forced to run on separate nodes.
  hardAntiAffinity: true

  # -- Additional affinities to add to the Redis server pods.
  additionalAffinities: {}

  # -- Assign custom [affinity] rules to the Redis pods.
  affinity: |

  # -- [Tolerations] for use with node taints for Redis pods.
  tolerations: []

  # -- Assign custom [TopologySpreadConstraints] rules to the Redis pods.
  ## https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
  topologySpreadConstraints:
    # -- Enable Redis HA topology spread constraints
    enabled: false
    # -- Max skew of pods tolerated
    # @default -- `""` (defaults to `1`)
    maxSkew: ""
    # -- Topology key for spread
    # @default -- `""` (defaults to `topology.kubernetes.io/zone`)
    topologyKey: ""
    # -- Enforcement policy, hard or soft
    # @default -- `""` (defaults to `ScheduleAnyway`)
    whenUnsatisfiable: ""
  # -- Redis HA statefulset container-level security context
  # @default -- See [values.yaml]
  containerSecurityContext:
    readOnlyRootFilesystem: true
  # -- External redis cache connection details. Takes effect if `redis-ha.enabled` is set to false
  # @default -- ignored
  external:
    port: 6379
    host: external-redis-host
    username: ""
    password: ""

## SeaweedFS subchart values. Set `seaweedfs.enabled` to `false` to use an external S3 bucket (set ctfd.uploadprovider.s3)
seaweedfs:
  # -- Deploys seaweedfs (set to false if you want to use an bucket)
  enabled: true  # set to false if you want to use an external bucket
  master:
    # -- seaweedfs-master replicas
    replicas: 1
    data:
      # -- seaweedfs data storage type
      type: "persistentVolumeClaim"
      # -- seaweedfs storage size
      size: 5Gi

  volume:
    # -- seaweedfs-volume replicas
    replicas: 1
  filer:
    # -- seaweedfs-filer replicas
    replicas: 1
    # -- seaweedfs-filer enable PVC for data persistence
    enablePVC: true
    # -- seaweedfs-filer PVC storage size
    storage: 5Gi
    data:
      # -- seaweedfs-filer data storage type
      type: "persistentVolumeClaim"
      # -- seaweedfs-filer storage size
      size: 5Gi
    s3:
      # -- seaweedfs-s3 enable. This enables S3 API (Should be left to `true`)
      enabled: true
      # # -- seaweedfs-s3 enable authentication
      # enableAuth: true
      # existingConfigSecret: seaweedfs-s3-secret
      # -- seaweedfs-s3 create bucket upon deploying
      createBuckets:
        - name: ctfd-bucket
  s3:
    # -- seaweedfs-s3 enable. This enables S3 API (Should be left to `true`)
    enabled: true
    # -- seaweedfs-s3 enable authentication
    enableAuth: true
    existingConfigSecret: seaweedfs-s3-secret
    # -- seaweedfs-s3 replicas
    replicas: 1
    ingress:
      enabled: true
      host: seaweedfs.example.com